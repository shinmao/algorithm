## Leetcode
| Problem        | Solution           | Cheat  | Writeup  |
| ------------- |-------------|-----|-----|
| Longest Palindromic Substring   | [5](./leetcode5.cpp)      |`dp`|   |
| Maximum Subarray   | [53](./leetcode53.java)      ||   |
| Edit Distance    | [72](./leetcode72.java)      |:star:|   |
| Longest Increasing Subsequence  | [300](./leetcode300.java)      |  |   |
| Longest Common Subsequence  | [1143](./leetcode1143.java)      |:star:|   |
| Longest Palindrome Subsequence    | [516](./leetcode516.java)      |:star:|   |
| Best Time to Buy and Sell Stock    | [121](./leetcode121.java)      |:star:| [blog](https://blog.1pwnch.com/posts/stock-problem-on-leetcode/#121-best-time-to-buy-and-sell-stock)  |
| Best Time to Buy and Sell Stock III   | [123](./leetcode123.java)      |:star:| [blog](https://blog.1pwnch.com/posts/stock-problem-on-leetcode/#123-best-time-to-buy-and-sell-stock-iii)  |
| Best Time to Buy and Sell Stock IV   | [188](./leetcode188.java)      || [blog](https://blog.1pwnch.com/posts/stock-problem-on-leetcode/#188-best-time-to-buy-and-sell-stock-iv)  |
| Best Time to Buy and Sell Stock with Cooldown   | [309](./leetcode309.java)      |:star:| [blog](https://blog.1pwnch.com/posts/stock-problem-on-leetcode/#309-best-time-to-buy-and-sell-stock-with-cooldown)  |
| Best Time to Buy and Sell Stock with Transaction Fee   | [714](./leetcode714.java)      || [blog](https://blog.1pwnch.com/posts/stock-problem-on-leetcode/#714-best-time-to-buy-and-sell-stock-with-transaction-fee)  |
| Maximum Product Subarray    | [152](./leetcode152.java)      |:star:|   |
| Degree of an Array    | [697](./leetcode697.java)      ||   |
| Binary Tree Level Order Traversal II    | [107](./leetcode107.cpp)      |`BFS`|   |
| Course Schedule    | [207](./leetcode207.java)      || [BFS Topological sort](#bfs-topological-sort)  |
| Course Schedule II   | [210](./leetcode210.java)      || [BFS Topological sort](#bfs-topological-sort)  |
| Course Schedule III   | [630](./leetcode630.java)      |:star:| [Sort in ascending or descending](#sort-in-ascending-order-or-descending-order) |
| Course Schedule IV   | [1462](./leetcode1462.java)      |:star:| Floyd-Warshall |
| Split Array into Consecutive Subsequences   | [659](./leetcode659.java)      |:star:|   |
| Triangle   | [120](./leetcode120.java)      |:star:| [DP](#dp)  |
| Palindrome Partitioning   | [131](./leetcode131.java)      |:star:|  |
| Palindrome Partitioning II   | [132](./leetcode132.java)      |:star:|  |
| Longest Consecutive Sequence   | [128](./leetcode128.java)      ||  |
| Largest Rectangle in Histogram   | [84](./leetcode84.java)      |:star:| monotonic stack |
| Next Greater Element I   | [496](./leetcode496.java)      || monotonic stack |
| Next Greater Element II   | [503](./leetcode503.java)      || monotonic stack |
| Trapping Rain Water I   | [42](./leetcode42.java)      |:star:| monotonic stack |
| Two Sum   | [1](./leetcode1.java)      || |
| Wildcard Matching   | [44](./leetcode44.java)      |:star:| [DP](#dp) |
| Regular Expression Matching   | [10](./leetcode10.java)      |:star:| [DP](#dp) |
| Word Break   | [139](./leetcode139.java)      |:star:| |
| Word Break II   | [140](./leetcode140.java)      |:star:| |
| Word Break III   | [140's modified](./leetcode140-1.java)     |:star:| |
| Subsets   | [78](./leetcode78.cpp)     || [DFS](#dfs) |
| Subsets II   | [90](./leetcode90.cpp)     || [DFS](#dfs) |
| Permutations   | [46](./leetcode46.cpp)     |:star:| [DFS](#dfs) |
| Permutations II  | [47](./leetcode47.cpp)     || [DFS](#dfs) |
| Combination Sum  | [39](./leetcode39.java)     || [DFS](#dfs) |
| Combination Sum II  | [40](./leetcode40.java)     || [DFS](#dfs) |
| N-Queens  | [51](./leetcode51.cpp)     |:star: `DFS`,`Bit`| [blog](https://blog.1pwnch.com/posts/n-queens-on-leetcode/) |
| N-Queens II  | [52](./leetcode52.cpp)     |:star: `DFS`,`Bit`| [blog](https://blog.1pwnch.com/posts/n-queens-on-leetcode/) |
| Number of 1 Bits  | [191](./leetcode191.cpp)     |`Bit`| [Bitwise Trick](#bitwise-trick) |
| Power of Two  | [231](./leetcode231.cpp)     |`Bit`| [Bitwise Trick](#bitwise-trick) |
| Counting Bits  | [338](./leetcode338.cpp)     |`Bit`| [Bitwise Trick](#bitwise-trick) |
| Single Number  | [136](./leetcode136.cpp)     |`Bit`| [Bitwise Trick](#bitwise-trick) |
| Single Number II  | [137](./leetcode137.cpp)     |:star: `Bit`,`truth table`| [Bitwise Trick](#bitwise-trick) |
| Single Number III  | [260](./leetcode260.cpp)     |:star: `Bit`| [Bitwise Trick](#bitwise-trick) |
| Prison Cells After N Days  | [957](./leetcode957.cpp)     |:star:| |
| Ugly Number II  | [264](./leetcode264.cpp)   |:star:| |
| Range Sum Query - Mutable  | [307](./leetcode307.cpp)   |:star: `Binary Indexed Tree`,`Segment Tree`|  |
| Binary Search Tree Iterator  | [173](./leetcode173.cpp)   |:star: `stack`|  |
| My Calendar III  | [732](./leetcode732.cpp)   |:star: `map`,`Segment Tree`|  |
| Count of Smaller Numbers After Self  | [315](./leetcode315.cpp)   |:star: `BST`| [blog](https://blog.1pwnch.com/posts/count-of-smaller-nums-after-self/) |
| Binary Search  | [704](./leetcode704.cpp)   |`Binary Search`|  |
| Search in Rotated Sorted Array  | [33](./leetcode33.cpp)   |`Binary Search`|  |
| First Bad Version  | [278](./leetcode278.cpp)   |`Binary Search`| [blog](https://blog.1pwnch.com/posts/explore-binary-search/) |
| Find Peak Element  | [162](./leetcode162.cpp)   |`Binary Search`| [blog](https://blog.1pwnch.com/posts/explore-binary-search/) |
| Find Minimum in Rotated Sorted Array  | [153](./leetcode153.cpp)   |`Binary Search`| [blog](https://blog.1pwnch.com/posts/explore-binary-search/) |
| Find First and Last Position of Element in Sorted Array  | [34](./leetcode34.cpp)   |:star: `Binary Search`| [blog](https://blog.1pwnch.com/posts/explore-binary-search/) |
| Find K Closest Elements  | [658](./leetcode658.cpp)   |:star: `Binary Search`,`Sliding Window`| [blog](https://blog.1pwnch.com/posts/explore-binary-search/) |
| Search in a Sorted Array of Unknown Size  | [702](./leetcode702.cpp)   |`Binary Search`| [blog](https://blog.1pwnch.com/posts/explore-binary-search/) |
| Most Visited Sector in a Circular Track  | [1560](./leetcode1560.cpp)   | |  |
| Two Sum IV - Input is a BST  | [653](./leetcode653.cpp)   |:star: `DFS`,`BST` |  |
| Search a 2D Matrix II  | [240](./leetcode240.cpp)   |:star: |  |
| Detect Pattern of Length M Repeated K or More Times  | [1566](./leetcode1566.cpp)   |:star: |  |

## 解題思維
### 遞迴
遞迴通常會在`return`裏又回call一次function。遞迴是用來**間接**告訴你答案的，而非直接的。某一層做的事都是一樣的，所以我們只要管好自己這層的工作就好。另外遞迴一定會有終止條件(類似在開頭寫個`if() return`之類的)。    
1. 分治法
2. 以遞迴來窮舉(也就是後來的dfs，用於traverse)
3. 又稱作tree search algorithm，以樹狀圖展開所有組合，取代brute force

1. 定義好function
2. 分解每一層的工作
3. 找到停止條件

> 面試的時候還是主動問一下能不能用recursion，通常是可以的！

### Binary search
:star: 跳躍法  
```cpp
int cur = start;
for(int jump = (end - start) / 2; jump > 0; jump /= 2) {
    while(cur + jump < end && arr[cur + jump] < target) cur += jump;
}
```
我喜歡把這個寫法叫做rabbit jump。這個寫法找到的是**最後一個小於target的位置**！rabbit從最左邊開始跳，一開始就選最大步，跳到正中間！接下來就是關鍵：我不會馬上換成小步，我會以一樣大的步伐在測看看會不會越界，或者會不會超過target。這也是為什麼內層是用**while而不是if**，用while來最有效率的運用我們最大跨步！注意迴圈的終止條件是當我們接下來的再跳的地方會大於或等於target，所以我們這個rabbit jump找的是最後一個小於target的位置，當然你可以依需求更改條件。  
這是迥然於我們平常用的binary search，我們常常會用左界和右界來限定search space [之前整理的一篇關於binary search的文章](https://blog.1pwnch.com/posts/explore-binary-search/)，唯一要注意的是：這個寫法我們要先確定 `arr[start] < target`，否則最後的結果會錯！

> 如果單純只是想找目標然後又想要偷懶的話(譬如比賽的時候): 建議用lower_bound(iterator, iterator, x)，會回傳第一個 >= x 的位置，時間複雜度也是O(logn)。要注意：如果所有元素都 < x 的話，則會回傳 .end()的位置，是越界的！ 順道提一下upper_bound回傳的則是 > x 的位置。

### Prefix sum 前綴和
* [leetcode 238](./leetcode238.cpp)
* [leetcode 560 + 變形題目](./leetcode560.cpp)
* [leetcode 209 + 雙指針](./leetcode209.cpp)
* [leetcode 862 + 單調棧](./leetcode862.cpp)
* [leetcode 644 + binary search](./leetcode644.cpp)
很重要的一點：我們應該focus在prefix而非在sum。除了sum之外也可以計算product，甚至紀錄min, max。  
```cpp
prefix_sum[i] = prefix_sum[i - 1] + arr[i];
```
常常用來求**區間**和，我可能還有雙指針和線段樹的選擇。不過切記線段樹不會那麼容易出現。

另外除了上面的式子，一定要記得定義邊界上的值。e.g. 上面當i等於0時就越界了。  
最好把**前0個元素prefix sum就是0**的想法寫進實現中。 e.g. 推薦創建`size() + 1`的陣列，然後從0開始，可以省掉很多麻煩...  

> 通常我們會想用O(n^2)去枚舉所有的區間，可是其實O(n^2)還不足以算出區間和，因為列舉出區間[i, j]之後，要把i,j之間的的數字加起來要另外O(n)的時間複雜度...

外面先用一層迴圈把`[0]`到`[i]`的`prefix sum`計算好，如果不想另外開空間也可以直接把結果存在輸入的array上。然後想要做`[0~1]`，`[0~2]`...`[0~n-1]`的判斷的話通常也會在這層迴圈就同時完成。
再來裡面都是處理**非從0開始**的subarray了。`prefix_sum`就可以幫我們把裡面的`O(n)`簡化成`O(1)`：  
```cpp
prefix[right] - prefix[left - i] = sum;
// prefix_sum - prefix_sum' = interval sum
```
這個`[left, right]`則是總和為sum的區間。換句話說，我只要拿兩個`prefix_sum`相減，就可以去看某個區間和囉！  

> subarray相關解有很大概率可以用prefix sum解

### BFS 拓墣排序
拓墣 用於有向無環圖，我們可以用它來判斷圖裡有沒有環，如果有那traverse也會失敗。拓墣排序還常拿來判斷兩個點之間有沒有路線，但這樣用 disjoint set 更快更簡潔。

### 動態規劃
1. make sure problem state  
we usually create an array for DP, we should make sure what each elements represents for first, which is also mean make sure problem state.  
First, **the state before the last step**. Take coins problem to get minimum number of coins for example, we want the sum of coins to be 27, then the state before the last step should be **(27 - ak)** if our coins are a1, a2, ...ak, ai can be 2 or 5.  
Second, **define subproblem**. So, what is the minimum number of coins whose sum is (27 - ak)? This is a subproblem. Now, we can **find the relationship between subproblem and original problem**. ak should be 2 or 5, so `P(27) = P(27 - 2) + 1` or `P(27) = P(27 - 5) + 1`.  
2. formulate problem transition  
problem transition can be interpreted as problem relationship, and **remember don't be confused by other states, only consider the two states**. we have found relationship between subproblem and original problem. it can be formulated as `P(x) = min(P(x-2) + 1, P(x-5) + 1)`.  
3. follow actual logic to set initial condition and boundary  
check some cases such as index out of bound. we always need to initialize some state by hands, e.g. `P(0) = 0`.  
4. make sure the order of calculation  
`P(1)`, `P(2)` first or `P(27)`, `P(26)` first? The best way to make sure about order is check formula. When you want to get the result of left side, have you already get the all results of right side?  

> DP is used to optimize the problem of O(2^n), O(n^n), O(n!) to O(n^2), O(n^3), or O(n^4) (Polynomial). If a problem can already be solved in poly time, then DP cannot be used on such problem.

Another way to handle with DP problem: Brute force or DFS first, and try to add some memoization to optimize it.  

### 動態規劃：子問題的定義
```java
dp[i]
```
* from index i to tail  
* from index 0 to i  
* first i  

```java
dp[i][j]
```
* from index i to j  
* first i in first sequence and first j in second sequence
* index i to tail in first sequence and index j to tail in second sequence

> subproblem asks the same question as original (most of all), e.g. how many palindrome can we get? then our subproblem is also getting number of palindrome from substring.

### DFS
dfs竅門:  
```java
opertaion 1
dfs()
operation 2
```
operation 2 would be reverse to offset the operation 1.

### C++ `push_back` v.s. Java `deep copy`
Once confused that we always need to do deep copy in java such like `result.add(new ArrayList<>(list);`; however, we just need to call `push_back(list);` in C++. After I reading the document, I figure out that `push_back` would just add a copied value to the tail of elements. Therefore, we don't need to worry that our operation in future will change the result again!

### 位運算技巧
You can apply bit operation to optimize your time complexity because computer can save the time of converting decimal to binary. For example, applying bit operation is recognized as the most efficient solution for N-Queens on leetcode!  
* [cxyxiaowu bit operation LC problem](https://www.cxyxiaowu.com/8990.html)  
* [BitwiseOperators](https://wiki.python.org/moin/BitwiseOperators)
* [Basics: how to convert negative decimal to binary](https://superuser.com/questions/975684/converting-negative-decimal-to-binary)
* [Basics: What is Bit Masking?](https://stackoverflow.com/questions/10493411/what-is-bit-masking)
* [bit operation](https://oi-wiki.org/math/bit/)